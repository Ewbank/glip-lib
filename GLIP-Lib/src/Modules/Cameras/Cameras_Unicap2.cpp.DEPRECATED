/*****************************************************************************************************************/
/**                                                                                                             **/
/**    GLIP-LIB                                                                                                 **/
/**    OpenGL Image Processing LIBrary                                                                          **/
/**                                                                                                             **/
/**    Author        : R. KERVICHE (ronan.kerviche@free.fr)                                                     **/
/**    LICENSE       : GPLv3                                                                                    **/
/**    Website       : http://sourceforge.net/projects/glip-lib/                                                **/
/**                                                                                                             **/
/**    File          : Cameras_Unicap2.cpp                                                                      **/
/**    Original Date : October 17th 2010                                                                        **/
/**                                                                                                             **/
/**    Description   : Unicap Camera handle                                                                     **/
/**                                                                                                             **/
/*****************************************************************************************************************/

#if defined(linux) || defined(__linux) || defined(__linux__)

// Includes :
	#include <iostream>
	#include <cstring>
	#include "./Cameras_Unicap2.hpp"
	#include "../../HdlTexture.hpp"
	#include "../../HdlPBO.hpp"
	#include "../../StreamManager.hpp"
	#include "../../HdlShader.hpp"
	#include "../../HdlFilter.hpp"

// Information Hub :
	// Data :
		int               UnicapHub::devCount = -1;
		unicap_device_t** UnicapHub::devices  = NULL;

	// Functions :
		UnicapHub::UnicapHub(void)
		{
			int status = STATUS_SUCCESS;

			// clean the data
			devices = new unicap_device_t*[MAX_UNICAP_DEVICES];
			for(int i=0; i<MAX_UNICAP_DEVICES; i++)
				devices[i] = (unicap_device_t*)NULL;

			// List all the existing devices :
			for(devCount = 0; SUCCESS (status) && (devCount < MAX_UNICAP_DEVICES); devCount++)
			{
				devices[devCount] = new unicap_device_t;
				status = unicap_enumerate_devices (NULL, devices[devCount], devCount);
		       	if (SUCCESS (status))
	         		std::cout << "UnicapHub::UnicapHub - New device : " << devCount << ", identifier : " << devices[devCount]->identifier << std::endl;
		       	else
	   		      	break;
				if(!SUCCESS(status))
					break;
	     	}

			if(devCount==0)
				std::cout << "UnicapHub::UnicapHub : no available devices" << std::endl;
		}

		void UnicapHub::DestroyUnicapHub(void)
		{
			if( devices!=NULL )
			{
				for(int i=0; i<MAX_UNICAP_DEVICES; i++)
					if(devices[i] != NULL) delete devices[i];
			}
		}

		int UnicapHub::getNumDevices(void)
		{
			return devCount;
		}

		unicap_device_t* UnicapHub::getDevice(int id)
		{
			if(id<0 || id >=MAX_UNICAP_DEVICES) return NULL;
			else
				return devices[id];
		}

// Camera
	// Functions :
		UnicapCamera::UnicapCamera(int id, FOURCC fmt, int w, int h, int hist) : running(false), enabled(false), newFrame(false), data(NULL), filter(NULL), imgSocket(NULL_SOCKET), image(NULL), size(0), OutputModule(hist, "UnicapCamera")
		{
			// Check device id :
			unicap_device_t* device = UnicapHub::getDevice(id);
			if( device!=NULL )
				unicap_open(&handle, device);
			else
			{
				std::cerr << "UnicapCamera::UnicapCamera : Can't open the device " << id << std::endl;
				return ;
			}

			// Check the handle
			if(!handle)
			{
				std::cerr << "UnicapCamera::UnicapCamera : Can't open the handle for device " << id << std::endl;
				return ;
			}

			// Setup the format
			const int MAX_FORMATS = 256;
			unicap_format_t formats[MAX_FORMATS];
			unicap_status_t status = STATUS_SUCCESS;
			int fmtId = -1;

			for (int format_count = 0; SUCCESS (status) && (format_count < MAX_FORMATS);
			format_count++)
			{
				status = unicap_enumerate_formats (handle, NULL, &formats[format_count], format_count);
				if (SUCCESS (status))
				{
					std::cout << "Format " << format_count << " identifier : " << formats[format_count].identifier << " FOURCC is " <<  getStringFOURCC(formats[format_count].fourcc) << std::endl;
					if(	formats[format_count].fourcc==fmt ) fmtId = format_count;
				}
				else
					break;
			}

			if(fmtId==-1)
			{
				std::cerr << "UnicapCamera::UnicapCamera : No formats for device " << id << " compatible with " << getStringFOURCC(fmt) << std::endl;
				return; // no formats
			}

			if(formats[fmtId].size_count!=0) //some formats exists
			{
				int s = -1;

				for (int i = 0; i < formats[fmtId].size_count; i++)
				{
					//std::cout << "    Format " << fmtId << ", size : " << formats[fmtId].sizes[i].width << 'X' << formats[fmtId].sizes[i].height << std::endl;
					if( formats[fmtId].sizes[i].width==w && formats[fmtId].sizes[i].height==h) s = i;
				}

				if(s==-1)
				{
					clean();
					std::cerr << "UnicapCamera::UnicapCamera : No compatible resolution for device " << id << " and format " << getStringFOURCC(fmt) << " and resolution " << w << 'x' << h << std::endl;
					return ;
				}

				formats[fmtId].size.width  = formats[fmtId].sizes[s].width;
				formats[fmtId].size.height = formats[fmtId].sizes[s].height;
				formats[fmtId].buffer_type = UNICAP_BUFFER_TYPE_SYSTEM;
			}

			if (!SUCCESS (unicap_set_format (handle, &formats[fmtId])))
			{
				std::cerr << "UnicapCamera::UnicapCamera : Can't setup the chosen format for device. Try to disconnect and reconnect the camera and stop all the applications using it" << id << std::endl;
				return ; // no compatible format
			}

			// Setup callback :
			status = unicap_register_callback(handle, UNICAP_EVENT_NEW_FRAME, (unicap_callback_t)newFrameCallback, (void *)this);
            /*if(status!=STATUS_SUCCESS)
            {
                std::cerr << "UnicapCamera::UnicapCamera : Can't add a callback to grab the frame" << std::endl;
                clean();
                return;
            }*/

			// Create the buffers
			size = getBufferSizeFromFOURCC(fmt, w, h);
			//std::cout << "Buffer size : " << size << std::endl;
			data = createBufferFromFOURCC(fmt, w, h);
			if(data==NULL)
			{
				std::cerr << "UnicapCamera::UnicapCamera : Can't create DATA corresponding to FOURCC" << std::endl;
				clean();
				return ;
			}

			// Create OpenGL object :
			image = createTextureFromFOURCC(fmt, w, h);
			image->write(data);
			if(image==NULL)
			{
				std::cerr << "UnicapCamera::UnicapCamera : Can't create IMAGE corresponding to FOURCC" << std::endl;
				clean();
				return ;
			}

			// prepare output :
			imgSocket = StreamManager::queryTextureSocket(image);

			// create an uncompression filter
			HdlTextureFormat texfmt(w,h,GL_RGB,GL_UNSIGNED_BYTE,GL_NEAREST,GL_NEAREST);
			const char** source = getCorrespondingFilter(fmt);
			ShaderSource src(source,false);
			//TO UNCOMMENT filter = new HdlFilter("UncompressionFilter", src, texfmt, 1, hist);
			filter->setInputSamplerName(0, "texInput");

			StreamManager::connect(filter->in(), imgSocket);

			for(int i=0; i<hist; i++)
				StreamManager::connect(out(i), filter->out(i));

			enabled = true;
		}

		UnicapCamera::~UnicapCamera(void)
		{
			clean();
		}

		void UnicapCamera::clean(void)
		{
			#define CLEAN(x)     if((x)!=NULL) {delete   x; x=NULL;}
			#define CLEAN_TAB(x) if((x)!=NULL) {delete[] x; x=NULL;}

			stop();
			enabled  = false;
			newFrame = false;
			if(handle) unicap_close(handle);
			CLEAN_TAB(data);
			CLEAN(image);
			StreamManager::releaseSocket(imgSocket);
			CLEAN(filter);
		}

		bool UnicapCamera::isEnabled(void)
		{
			return enabled;
		}

		bool UnicapCamera::isRunning(void)
		{
			return running;
		}

		bool UnicapCamera::stop(void)
		{
			if(running)
			{
				unicap_status_t status = unicap_stop_capture(handle);
                if(status!=STATUS_SUCCESS)
                    std::cerr << "UnicapCamera::stop : Can't stop the camera despite it has been successfully set-up (Unicap error)" << std::endl;
                else
				    running = false;
			}
		}

		bool UnicapCamera::run(void)
		{
			if(!running && enabled)
			{
				unicap_status_t status = unicap_start_capture(handle);
                if(status!=STATUS_SUCCESS)
                    std::cerr << "UnicapCamera::run : Can't run the camera despite it has been successfully set-up (Unicap error)" << std::endl;
                else
                    running = true;
			}
            else
                std::cerr << "UnicapCamera::run : Can't run the camera, it is already running or hasn't been setup correctly" << std::endl;
		}

		bool UnicapCamera::isNewFrame(void)
		{
			if(newFrame && enabled && running)
			{
				image->write(data);
				filter->process();
				newFrame = false;
				return true;
			}
			else
				return false;
		}

	// Callback
		void UnicapCamera::newFrameCallback(unicap_event_t event, unicap_handle_t handle, unicap_data_buffer_t* buffer, void *usr_data)
		{
			UnicapCamera* ptr = static_cast<UnicapCamera*>(usr_data);
			ptr->newFrame = true;
			memcpy(ptr->data, buffer->data, ptr->size);
		}

// Tools
	// FOURCC
	FOURCC      getFOURCC(char* str)
	{
		FOURCC res = (FOURCC)str[0];
		res = (res << 8) | (FOURCC)str[1];
		res = (res << 8) | (FOURCC)str[2];
		res = (res << 8) | (FOURCC)str[3];
		return res;
	}

	std::string getStringFOURCC(FOURCC a)
	{
		std::string res;

		res += (char)((a & (255 << 24)) >> 24);
		res += (char)((a & (255 << 16)) >> 16);
		res += (char)((a & (255 <<  8)) >>  8);
		res += (char)( a &  255);

		return res;
	}

#endif

