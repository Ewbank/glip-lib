/*****************************************************************************************************************/
/**                                                                                                             **/
/**    GLIP-LIB                                                                                                 **/
/**    OpenGL Image Processing LIBrary                                                                          **/
/**                                                                                                             **/
/**    Author        : R. KERVICHE (ronan.kerviche@free.fr)                                                     **/
/**    LICENSE       : GPLv3                                                                                    **/
/**    Website       : http://sourceforge.net/projects/glip-lib/                                                **/
/**                                                                                                             **/
/**    File          : Cameras_Unicap2.cpp                                                                      **/
/**    Original Date : October 17th 2010                                                                        **/
/**                                                                                                             **/
/**    Description   : Unicap Camera handle                                                                     **/
/**                                                                                                             **/
/*****************************************************************************************************************/

#if defined(linux) || defined(__linux) || defined(__linux__)

// Includes : 
	#include <iostream>
	#include <cstring>
	#include "./Cameras_Unicap2.hpp"
	#include "../../HdlPBO.hpp"
	#include "../../HdlTexture.hpp"
	#include "../../HdlShader.hpp"
	#include "../../HdlFilter.hpp"

// Data
	#define NUMERUS_FOURCC      (5)
	FOURCC __inputCode[]        = {GET_FOURCC('V','Y','U','Y'), GET_FOURCC('Y','V','Y','U'), GET_FOURCC('3','B','G','R'), GET_FOURCC('0','0','8','Y'), 0};
	float  __WidthMultiplier[]  = {0.5,                         0.5,                         1.0,                         1.0,                         0.0};
	float  __HeightMultiplier[] = {1.0,                         1.0,                         1.0,                         1.0,                         0.0};
	int    __PixelSize[]        = {4,                           4,                           3,                           1,                           0};
	GLenum __glPixelFormat[]    = {GL_RGBA,                     GL_RGBA,                     GL_RGB,                      GL_RED,                      0};
	GLenum __glPixelDepth[]     = {GL_UNSIGNED_BYTE,            GL_UNSIGNED_BYTE,            GL_UNSIGNED_BYTE,            GL_UNSIGNED_BYTE,            0};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Shader sources
					  /*ABGR*/
	const char* _filter_VYUY_2_RGB24[]  = { /* 1*/ "uniform sampler2D texInput; \n",
		                               		/* 2*/ "void main() \n",
		                              		/* 3*/ "{ \n",
		                               		/* 4*/ "    vec4 col = texture(texInput, gl_TexCoord[0].st); \n",
								       		/* 5*/ "    vec4 colOut; \n",
											/* 6*/ "    ivec2 sz = textureSize(texInput, 0); \n",
											/* 7*/ "    int width = sz.x; \n",
                                            /* 8*/ "    int px = int(gl_TexCoord[0].s * float(width)); \n",
								      		/* 9*/ "    col.g = col.g*0.872 - 0.436; \n",
								       		/*10*/ "    col.a = col.a*1.23 - 0.615; \n",
								       		/*11*/ "    if( mod(px,2)==1 ) \n",
								       		/*12*/ "        col.r = col.b; \n",
		                               		/*13*/ "    colOut.r = col.r + 1.140*col.a; \n",
		                               		/*14*/ "    colOut.g = col.r - 0.395*col.g - 0.581*col.a; \n",
 		                               		/*15*/ "    colOut.b = col.r + 2.032*col.g; \n",
		                               		/*16*/ "    gl_FragColor = colOut; \n",
								       		/*17*/ "} \n",
											  0 };

					  /*ABGR*/
	const char* _filter_YVYU_2_RGB24[]  = { /* 1*/ "uniform sampler2D texInput; \n",
		                               		/* 2*/ "void main() \n",
		                              		/* 3*/ "{ \n",
		                               		/* 4*/ "    vec4 col = texture(texInput, gl_TexCoord[0].st); \n",
								       		/* 5*/ "    vec4 colOut; \n",
											/* 6*/ "    ivec2 sz = textureSize(texInput, 0); \n",
											/* 7*/ "    int width = sz.x; \n",
                                            /* 8*/ "    int px = int(gl_TexCoord[0].s * float(width)); \n",
								      		/* 9*/ "    col.r = col.r*0.872 - 0.436; \n",
								       		/*10*/ "    col.b = col.b*1.23 - 0.615; \n",
								       		/*11*/ "    if( mod(px,2)==0 ) \n",
								       		/*12*/ "        col.g = col.a; \n",
		                               		/*13*/ "    colOut.r = col.g + 1.140*col.b; \n",
		                               		/*14*/ "    colOut.g = col.g - 0.395*col.r - 0.581*col.b; \n",
 		                               		/*15*/ "    colOut.b = col.g + 2.032*col.r; \n",
		                               		/*16*/ "    gl_FragColor = colOut; \n",
								       		/*17*/ "} \n",
											  0 };

	const char* _filter_3BGR_2_RGB24[]  = { /* 1*/ "uniform sampler2D texInput; \n",
		                               		/* 2*/ "void main() \n",
		                              		/* 3*/ "{ \n",
		                               		/* 4*/ "    vec4 col = texture(texInput, gl_TexCoord[0].st); \n",
								       		/* 5*/ "    /*vec4 colOut; \n",
											/* 6*/ "    ivec2 sz = textureSize(texInput, 0); \n",
											/* 7*/ "    int width = sz.x; \n",
                                            /* 8*/ "    int px = int(gl_TexCoord[0].s * float(width)); \n",
								      		/* 9*/ "    col.r = col.r*0.872 - 0.436; \n",
								       		/*10*/ "    col.b = col.b*1.23 - 0.615; \n",
								       		/*11*/ "    if( mod(px,2)==0 ) \n",
								       		/*12*/ "        col.g = col.a; \n",
		                               		/*13*/ "    colOut.r = col.g + 1.140*col.b; \n",
		                               		/*14*/ "    colOut.g = col.g - 0.395*col.r - 0.581*col.b; \n",
 		                               		/*15*/ "    colOut.b = col.g + 2.032*col.r; \n*/",
		                               		/*16*/ "    gl_FragColor = col; \n",
								       		/*17*/ "} \n",
											  0 };

	const char* _filter_008Y_2_RGB24[]  = { /* 1*/ "uniform sampler2D texInput; \n",
		                               		/* 2*/ "void main() \n",
		                              		/* 3*/ "{ \n",
											/* 4*/ "    ivec2 sz    = textureSize(texInput, 0); \n",
											/* 5*/ "    vec2 pos    = gl_TexCoord[0].st; \n",
											/* 6*/ "    int width   = sz.x; \n",
											/* 7*/ "    int height  = sz.y; \n",
											/* 8*/ "    float dx    = 1.0/float(sz.x); \n",
											/* 9*/ "    float dy    = 1.0/float(sz.y); \n",
                                            /*10*/ "    int px = int(gl_TexCoord[0].s * float(width)); \n",
                                            /*11*/ "    int py = int(gl_TexCoord[0].t * float(height)); \n",
								       		/*12*/ "    if( mod(px,2)==1 ) \n",
								       		/*13*/ "        pos.s = pos.s - dx; \n",
											/*14*/ "    if( mod(py,2)==1 ) \n",
								       		/*15*/ "        pos.t = pos.t - dy; \n",
											/*16*/ "    vec4 colred    = textureLod(texInput, pos, 0); \n",
		                               		/*17*/ "    vec4 colgreen1 = textureLod(texInput, pos + vec2(dx, 0.0), 0); \n",
		                               		/*18*/ "    vec4 colgreen2 = textureLod(texInput, pos + vec2(0.0, dy), 0);\n",
											/*19*/ "    vec4 colblue   = textureLod(texInput, pos + vec2(dx,  dy), 0); \n",
		                               		/*20*/ "    gl_FragColor = vec4(colred.r, (colgreen1.r+colgreen2.r)/2.0, colblue.r, 1.0); \n",
											/*21*/ "    //gl_FragColor = vec4(colred.r, colred.r, colred.r, 1.0); \n",
								       		/*22*/ "} \n",
											  0 };

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Tools
	int findIndexInFOURCCList(FOURCC code)
	{
		int id = -1;
		for(int i=0; i<NUMERUS_FOURCC; i++)
			if(__inputCode[i] == code)
			{
				id = i;
				break;
			}
	
		if(id==-1)
			std::cout << "Unknown FOURCC : " << getStringFOURCC(code) << std::endl;

		return id;
	}

	int getBufferSizeFromFOURCC(FOURCC code, int w, int h)
	{
		int id = findIndexInFOURCCList(code);
		return w*__WidthMultiplier[id]*h*__HeightMultiplier[id]*__PixelSize[id];
	}

	char* createBufferFromFOURCC(FOURCC code, int w, int h)
	{
		int id = findIndexInFOURCCList(code);

		if(id==-1) return NULL;

		int size = getBufferSizeFromFOURCC(code, w, h);
		char* res = new char[size];
		memset(res, 128, size);

		return res;
	}
		
	HdlTexture* createTextureFromFOURCC(FOURCC code, int w, int h)
	{
		int id = findIndexInFOURCCList(code);

		if(id==-1) return NULL;

		HdlTextureFormat fmt(w*__WidthMultiplier[id], h*__HeightMultiplier[id], __glPixelFormat[id], __glPixelDepth[id], GL_LINEAR, GL_LINEAR);
		return new HdlTexture(fmt);
	}

	const char** getCorrespondingFilter(FOURCC code)
	{
		switch(code)
		{
			case GET_FOURCC('V','Y','U','Y'): return _filter_VYUY_2_RGB24;
			case GET_FOURCC('Y','V','Y','U'): return _filter_YVYU_2_RGB24;
			case GET_FOURCC('3','B','G','R'): return _filter_3BGR_2_RGB24;
			case GET_FOURCC('0','0','8','Y'): return _filter_008Y_2_RGB24;
			default : std::cerr << "Unicap Hub : Don't have corresponding filter to uncompress data! (FOURCC is " << getStringFOURCC(code) << std::endl; return NULL;
		}
	}
		
#endif



