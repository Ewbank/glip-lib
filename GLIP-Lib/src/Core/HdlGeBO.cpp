/* ************************************************************************************************************* */
/*                                                                                                               */
/*     GLIP-LIB                                                                                                  */
/*     OpenGL Image Processing LIBrary                                                                           */
/*                                                                                                               */
/*     Author        : R. KERVICHE (ronan.kerviche@free.fr)                                                      */
/*     LICENSE       : GPLv3                                                                                     */
/*     Website       : http://sourceforge.net/projects/glip-lib/                                                 */
/*                                                                                                               */
/*     File          : HdlGeBO.cpp                                                                               */
/*     Original Date : August 7th 2010                                                                           */
/*                                                                                                               */
/*     Description   : OpenGL Pixel Buffer Object Handle                                                         */
/*                                                                                                               */
/* ************************************************************************************************************* */

/**
 * \file    HdlGeBO.cpp
 * \brief   OpenGL Generic handle for Buffer Objects (VBO, PBO, VAO, ...)
 * \author  R. KERVICHE
 * \version 0.6
 * \date    February 6th 2011
*/

#include "HdlGeBO.hpp"
#include "GLIPLib.hpp"

using namespace Glip::CoreGL;

// Data
	bool HdlGeBO::binding[4] = {false, false, false, false};
	bool HdlGeBO::mapping[4] = {false, false, false, false};

// Functions
	/**
	\fn    HdlGeBO::HdlGeBO(unsigned int _size, GLenum infoTarget, GLenum infoUsage) : size(_size)
	\brief HdlGeBO Construtor.

	\param _size      Size of the buffer, in bytes.
	\param infoTarget Target kind, among GL_ARRAY_BUFFER_ARB, GL_ELEMENT_ARRAY_BUFFER_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, GL_PIXEL_PACK_BUFFER_ARB.
	\param infoUsage  Usage kind among GL_STATIC_DRAW_ARB, GL_STATIC_READ_ARB, GL_STATIC_COPY_ARB, GL_DYNAMIC_DRAW_ARB, GL_DYNAMIC_READ_ARB, GL_DYNAMIC_COPY_ARB, GL_STREAM_DRAW_ARB, GL_STREAM_READ_ARB, GL_STREAM_COPY_ARB.
	**/
	HdlGeBO::HdlGeBO(int _size, GLenum infoTarget, GLenum infoUsage) : size(_size)
	{
		// Generate the buffer
		glGenBuffers(1, &bufferId);

		// Bind it
		glBindBuffer(infoTarget, bufferId);

		// Allocate some space
		glBufferData(infoTarget, size, NULL, infoUsage);

		// Release point
		HdlGeBO::unbind(infoTarget);

		buildTarget = infoTarget;
		buildUsage  = infoUsage;

		#ifdef __DEVELOPMENT_VERBOSE__
			std::cout << "New GeBO, errors : " << std::endl;
			glErrors(true, false);
		#endif
	}

	/**
	\fn    HdlGeBO::HdlGeBO(GLuint id, unsigned int _size) : size(_size)
	\brief HdlGeBO Construtor.

	\param id    GLuint id of the Buffer Object to be mapped in.
	\param _size Size of the buffer, in bytes.
	\param infoTarget Target kind, among GL_ARRAY_BUFFER_ARB, GL_ELEMENT_ARRAY_BUFFER_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, GL_PIXEL_PACK_BUFFER_ARB.
	\param infoUsage  Usage kind among GL_STATIC_DRAW_ARB, GL_STATIC_READ_ARB, GL_STATIC_COPY_ARB, GL_DYNAMIC_DRAW_ARB, GL_DYNAMIC_READ_ARB, GL_DYNAMIC_COPY_ARB, GL_STREAM_DRAW_ARB, GL_STREAM_READ_ARB, GL_STREAM_COPY_ARB.
	**/
	HdlGeBO::HdlGeBO(GLuint id, int _size, GLenum infoTarget, GLenum infoUsage) : size(_size)
	{
		#ifdef __DEVELOPMENT_VERBOSE__
		std::cerr << "ERROR HdlGeBO::HdlGeBO : a copy was made" << std::endl;
		#endif
		// Just copy the link
		bufferId = id;

		// And data
		buildTarget = infoTarget;
		buildUsage  = infoUsage;
	}

	HdlGeBO::~HdlGeBO(void)
	{
		// Delete the object
		glDeleteBuffers(1, &bufferId);
	}

	/**
	\fn    unsigned int HdlGeBO::getSize(void)
	\brief Get the size of the Buffer Object.

	\return Size of the BO in bytes.
	**/
	int HdlGeBO::getSize(void)
	{
		return size;
	}

	/**
	\fn    GLuint HdlGeBO::getID(void)
	\brief Get the ID of the Buffer Object.

	\return ID of the Buffer Object
	**/
	GLuint HdlGeBO::getID(void)
	{
		return bufferId;
	}

	/**
	\fn    GLenum HdlGeBO::getTarget(void)
	\brief Get the target of the Buffer Object.

	\return Target of the Buffer Object, among : GL_ARRAY_BUFFER_ARB, GL_ELEMENT_ARRAY_BUFFER_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, GL_PIXEL_PACK_BUFFER_ARB.
	**/
	GLenum HdlGeBO::getTarget(void)
	{
		return buildTarget;
	}

	/**
	\fn    GLenum HdlGeBO::getUsage(void)
	\brief Get the usage of the Buffer Object.

	\return ID of the Buffer Object, among : GL_STATIC_DRAW_ARB, GL_STATIC_READ_ARB, GL_STATIC_COPY_ARB, GL_DYNAMIC_DRAW_ARB, GL_DYNAMIC_READ_ARB, GL_DYNAMIC_COPY_ARB, GL_STREAM_DRAW_ARB, GL_STREAM_READ_ARB, GL_STREAM_COPY_ARB.
	**/
	GLenum HdlGeBO::getUsage(void)
	{
		return buildUsage;
	}

	/**
	\fn    void HdlGeBO::bind(GLenum target)
	\brief Bind the Buffer Object.
	**/
	void HdlGeBO::bind(GLenum target)
	{
		if(target==GL_NONE) target = getTarget();
		glBindBuffer(target, bufferId);
		binding[getIDTarget(target)] = true;
	}

	/**
	\fn    void* HdlGeBO::map(GLenum target, GLenum access)
	\brief Map the Buffer Object into the CPU memory.

	\param target Target mapping point, among GL_ARRAY_BUFFER_ARB, GL_ELEMENT_ARRAY_BUFFER_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, GL_PIXEL_PACK_BUFFER_ARB.
	\param access Kind of access, among GL_READ_ONLY_ARB, GL_WRITE_ONLY_ARB, GL_READ_WRITE_ARB.

	\return Pointer in CPU memory.
	**/
	void* HdlGeBO::map(GLenum target, GLenum access)
	{
		glDebug();
		HdlGeBO::unmap(target);
		#ifdef __DEVELOPMENT_VERBOSE__
			std::cout << "Unmap - target : " << glParamName(target) << " access : " << glParamName(access) << " -> " ; glErrors(true, false);
		#endif
		bind(target);
		#ifdef __DEVELOPMENT_VERBOSE__
			std::cout << "Bind : "; glErrors(true, false);
		#endif
		mapping[getIDTarget(target)] = true;
		return glMapBufferARB(target, access);
	}

	void HdlGeBO::write(void* data)
	{
		bind();

		glBufferData(getTarget(), static_cast<GLsizeiptr>(size), reinterpret_cast<const GLvoid *>(data), getUsage());
	}

	void HdlGeBO::subWrite(void* data, int size, int offset)
	{
		bind();

		glBufferSubData(getTarget(),  static_cast<GLintptr>(offset), static_cast<GLsizeiptr>(size),  reinterpret_cast<const GLvoid *>(data));
	}


// Static tools
	int HdlGeBO::getIDTarget(GLenum target)
	{
		switch(target)
		{
			case GL_ARRAY_BUFFER_ARB :		return 0;
			case GL_ELEMENT_ARRAY_BUFFER_ARB :	return 1;
			case GL_PIXEL_UNPACK_BUFFER_ARB :	return 2;
			case GL_PIXEL_PACK_BUFFER_ARB :		return 3;
			default :
				throw Exception("HdlGeBO::getIDTarget - Unknown target : " + glParamName(target), __FILE__, __LINE__);
		}
	}

	/**
	\fn    void HdlGeBO::unbind(GLenum target)
	\brief Unbind any Buffer Object.

	\param target Target binding point, among GL_ARRAY_BUFFER_ARB, GL_ELEMENT_ARRAY_BUFFER_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, GL_PIXEL_PACK_BUFFER_ARB.
	**/
	void HdlGeBO::unbind(GLenum target)
	{
		glBindBuffer(target, 0);
		binding[getIDTarget(target)] = false;
	}

	/**
	\fn    void HdlGeBO::unbind(GLenum target)
	\brief Unmap any Buffer Object.

	\param target Target binding point, among GL_ARRAY_BUFFER_ARB, GL_ELEMENT_ARRAY_BUFFER_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, GL_PIXEL_PACK_BUFFER_ARB.
	**/
	void HdlGeBO::unmap(GLenum target)
	{
		if(isMapped(target))
		{
			glUnmapBufferARB(target);
			mapping[getIDTarget(target)] = false;
		}
	}

	bool HdlGeBO::isBound(GLenum target)
	{
		return binding[getIDTarget(target)];
	}

	bool HdlGeBO::isMapped(GLenum target)
	{
		return mapping[getIDTarget(target)];
	}
