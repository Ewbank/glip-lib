TEXTURE_FORMAT:colorDistribution(255,1,GL_RGB32F_ARB,GL_FLOAT,GL_NEAREST,GL_NEAREST);
TEXTURE_FORMAT:histogramWindow(640,480,GL_RGB,GL_UNSIGNED_BYTE,GL_LINEAR,GL_LINEAR);

SHADER_SOURCE:vertexHistogram()
{
	#version 130

	uniform sampler2D tex0;
	uniform int c; // 0:red 1:green 2:blue

	void main()
	{
		// Vertex texture fetching :
		vec4 col = textureLod(tex0, gl_Vertex.xy+vec2(0.5,0.5), 0.0);

		// "Payload"
		gl_FrontColor = vec4(0.0,0.0,1.0,1.0);

		// Compute the new position!
		float tmp = 0.0;
		if(c==0)
			tmp = col.r;
		if(c==1)
			tmp = col.g;
		if(c==2)
			tmp = col.b;

		// Done
		gl_Position.x = (tmp-0.5)*2.0;
		gl_Position.y = 0.0;
		gl_Position.z = 0.0;
	}
}

SHADER_SOURCE:fragHistogram()
{
	#version 130

	uniform float nrm, scale;

	out vec4 outText;

	void main()
	{
		if(gl_Color.b>0.5)
			outText = vec4(nrm,nrm,nrm,1.0)*scale;
		else
			outText = vec4(0.0,0.0,0.0,0.0);
	}
}

SHADER_SOURCE:fragWinHist()
{
	#version 130
	uniform sampler2D fRed, fGreen, fBlue, tex0;
	out vec4 outText;

	void main()
	{
		vec2 pos = gl_TexCoord[0].st;
		vec4 pRed 	= textureLod(fRed, 	pos, 0);
		vec4 pGreen	= textureLod(fGreen, 	pos, 0);
		vec4 pBlue	= textureLod(fBlue,	pos, 0);
		vec4 col	= textureLod(tex0, 	pos, 0);

		if(pos.t<pRed.r )
			outText.r = 1.0;
		else
			outText.r = col.r;
		if(pos.t<pGreen.r )
			outText.g = 1.0;
		else
			outText.g = col.g;
		if(pos.t<pBlue.r )
			outText.b = 1.0;
		else
			outText.b = col.b;
	}
}


FILTER_LAYOUT:filterHistogram(colorDistribution, fragHistogram, vertexHistogram, CLEARING_ON, BLENDING_ON);
FILTER_LAYOUT:windowHistogram(histogramWindow, fragWinHist);

PIPELINE_MAIN:pipelineHistogram()
{
	INPUT_PORTS(i0);
	OUTPUT_PORTS(o0);

	FILTER_INSTANCE:instHistRed(filterHistogram);
	FILTER_INSTANCE:instHistGreen(filterHistogram);
	FILTER_INSTANCE:instHistBlue(filterHistogram);
	FILTER_INSTANCE:instWin(windowHistogram);

	CONNECTION(THIS, i0, instHistRed, tex0);
	CONNECTION(THIS, i0, instHistGreen, tex0);
	CONNECTION(THIS, i0, instHistBlue, tex0);
	CONNECTION(instHistRed, outText, instWin, fRed);
	CONNECTION(instHistGreen, outText, instWin, fGreen);
	CONNECTION(instHistBlue, outText, instWin, fBlue);
	CONNECTION(THIS, i0, instWin, tex0);
	CONNECTION(instWin, outText, THIS, o0);
}
